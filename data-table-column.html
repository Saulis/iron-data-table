<link rel="import" href="data-table-column-filter.html">
<link rel="import" href="templatizer.html">

<dom-module id="data-table-column">
  <template>
    <template id="header">
      <data-table-column-filter label="[[column.name]]" value="{{column.filterValue}}" hidden$="[[!column.filterBy]]"></data-table-column-filter>
      <div hidden$="[[column.filterBy]]">[[column.name]]</div>
    </template>
  </template>
  <script>
    Polymer({
      is: 'data-table-column',

      behaviors: [
        Polymer.Templatizer,
      ],

      properties: {
        /**
         * If `true`, cell contents will be aligned on the right
         */
        alignRight: {
          type: Boolean,
          value: false
        },

        /**
         * Name of the column. This value is displayed in the header cell of the column
         */
        name: {
          type: String,
          notify: true,
          value: ''
        },

        /**
         * Path to a property that will be filtered by this column. If set, a filter input
         * will be automaticelly placed on the header cell of the column.
         */
        filterBy: String,

        /**
         * Filter value that will be used to filter the items using the property defined
         * in `filterBy` property.
         */
        filterValue: String,

        /**
         * Minimum width of the column
         */
        width: {
          type: String,
          notify: true,
          value: "100px"
        },

        /**
         * Ratio of how the extra space between columns is distributed. If every cell
         * has the same `flex` value, the space will be distributed evenly.
         */
        flex: {
          type: Number,
          notify: true,
          value: 1
        },

        /**
         * If `true`, the cells of this column will be hidden.
         */
        hidden: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * Display order of the column in relation with the other columns.
         */
        order: {
          type: Number,
          notify: true
        },

        /**
         * Path to a property that will be sorted by this column. If set, a sorting
         * indicator will be automatically placed in the header cell of this column.
         */
        sortBy: {
          type: String
        },

        /**
         * Template for the header cell
         */
        headerTemplate: {
          type: Object,
          readOnly: true,
          value: function() {
            var custom = Polymer.dom(this).querySelector('template[is=header]');

            if (custom) {
              return custom;
            }

            return Polymer.dom(this.root).querySelector('#header');
          }
        },

        /**
         * Reference to the parent <iron-data-table> element.
         */
        table: Object,

        /**
         * Template for the row item cell
         */
        template: {
          type: Object,
          readOnly: true,
          value: function() {
            return Polymer.dom(this).querySelector('template:not([is=header])');
          }
        },

        _templateInstances: {
          type: Array,
          value: function() {
            return [];
          }
        },

        _forwardedParentProps: {
          type: Object,
          value: function() {
            return {};
          }
        },

        templatizeRow: {
          type: Object,
          notify: true,
          value: function() {
           return function(parentElement) {
             return this._templatize(this.template, parentElement);
           }.bind(this)
          }
        },

        templatizeHeader: {
          type: Object,
          notify: true,
          value: function() {
           return function(parentElement) {
             return this._templatize(this.headerTemplate, parentElement);
           }.bind(this);
          }
        }
      },

      observers: ['_forwardedParentPropsChanged(_forwardedParentProps.*)',
        '_templateInstancesChanged(_templateInstances.splices)',
        '_filterValueChanged(filterValue, filterBy)',
        '_filterByChanged(filterBy)',
        '_nameChanged(name)',
        '_sortByChanged(table, sortBy)'
      ],

      _nameChanged: function(name) {
        this._updateTemplateProperty('column.name', name);
      },

      _sortByChanged: function(table, sortBy) {
        // column.sortBy is currently used iron-data-table so we need to notify
        // it for changes.
        if (table.columns) {
          var index = table.columns.indexOf(this);
          table.notifyPath('columns.' + index + '.sortBy', sortBy);
        }

        // someone might be binding to sortBy in the header template so let's
        // update that just in case.
        this._updateTemplateProperty('column.sortBy', sortBy);
      },

      _filterByChanged: function(filterBy) {
        this._updateTemplateProperty('column.filterBy', filterBy);
      },

      _filterValueChanged: function(filterValue, filterBy) {
        this._updateTemplateProperty('column.filterValue', filterValue);
        this.fire('column-filter-changed', {value: filterValue, filterBy: filterBy});
      },

      _updateTemplateProperty: function(prop, value) {
        if (this._templateInstances) {
          var changeRecord = {base: {}};
          changeRecord.base[prop] = value;
          this._forwardedParentPropsChanged(changeRecord);
        }
      },

      _forwardedParentPropsChanged: function(changeRecord) {
        // TODO: need to make sure this works with nested paths also. [[foo.bar]] etc.
        for (var prop in changeRecord.base) {
          this._templateInstances.forEach(function(t) {
            t.set(prop, changeRecord.base[prop]);
          });
        }
      },

      _templateInstancesChanged: function(changeRecord) {
        // TODO: (Saulis) make sure _templateInstances length is correct. Earlier testing seems producing weird results.
        if (changeRecord && changeRecord.indexSplices) {

          changeRecord.indexSplices.forEach(function(s) {
            var addedInstance = s.object[s.index];

            for (var prop in this._forwardedParentProps) {
              addedInstance[prop] = this._forwardedParentProps[prop];
            }
          }.bind(this));
        }
      },

      _templatize: function(template, parentElement) {
        // TODO: extract and move template instances inside the templatizer element.
        var t = new saulis.Templatizer(this);
        t.templatize(template);
        var instance = t.stamp();

        this.push('_templateInstances', instance);
        Polymer.dom(parentElement).insertBefore(instance.root, Polymer.dom(parentElement).firstElementChild);

        return {
          bind: function(data) {
            for (var prop in data) {
              instance[prop] = data[prop];
            }
          }
        };
      }
    });
  </script>
</dom-module>
